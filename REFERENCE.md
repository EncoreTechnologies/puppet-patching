# Reference
<!-- DO NOT EDIT: This document was generated by Puppet Strings -->

## Table of Contents

**Classes**

* [`patching`](#patching): allows global customization of the patching resources
* [`patching::params`](#patchingparams): params for the patching module resources

**Defined types**

* [`patching::script`](#patchingscript): manages a script for custom patching actions

**Functions**

* [`patching::snapshot_vmware`](#patchingsnapshot_vmware): Creates/deletes snapshots on VMs using the VMware vSphere API.
* [`patching::target_names`](#patchingtarget_names): Returns an array of names, one for each target, based on the $name_property

**Tasks**

* [`available_updates`](#available_updates): Collects information about available updates on a target system
* [`available_updates_linux`](#available_updates_linux): Collects information about available updates on a target system
* [`available_updates_windows`](#available_updates_windows): Collects information about available updates on a target system
* [`cache_remove`](#cache_remove): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_remove_linux`](#cache_remove_linux): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_remove_windows`](#cache_remove_windows): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_update`](#cache_update): Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this m
* [`cache_update_linux`](#cache_update_linux): Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this m
* [`cache_update_windows`](#cache_update_windows): Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this m
* [`history`](#history): Reads the update history from the JSON 'result_file'.
* [`monitoring_solarwinds`](#monitoring_solarwinds): Enable or disable monitoring alerts on hosts in SolarWinds.
* [`post_update`](#post_update): Run post-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this a
* [`pre_post_update_linux`](#pre_post_update_linux): Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.
* [`pre_post_update_windows`](#pre_post_update_windows): Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.
* [`pre_update`](#pre_update): Run pre-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this al
* [`puppet_facts`](#puppet_facts): Gather system facts using 'puppet facts'. Puppet agent MUST be installed for this to work.
* [`reboot_required`](#reboot_required): Checks if a reboot is pending
* [`reboot_required_linux`](#reboot_required_linux): Checks if a reboot is pending
* [`reboot_required_windows`](#reboot_required_windows): Checks if a reboot is pending
* [`update`](#update): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windo
* [`update_history`](#update_history): Reads the update history from the JSON 'result_file'.
* [`update_history_linux`](#update_history_linux): Reads the update history from the JSON 'result_file'.
* [`update_history_windows`](#update_history_windows): Reads the update history from the JSON 'result_file'.
* [`update_linux`](#update_linux): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windo
* [`update_windows`](#update_windows): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windo

**Plans**

* [`patching`](#patching): Our generic and semi-opinionated workflow.
* [`patching::available_updates`](#patchingavailable_updates): Checks all nodes for available updates reported by their Operating System.
* [`patching::check_online`](#patchingcheck_online): Checks each node to see they're online.
* [`patching::check_puppet`](#patchingcheck_puppet): Checks each node to see if Puppet is installed, then gather Facts on all nodes.
* [`patching::deploy_scripts`](#patchingdeploy_scripts): 
* [`patching::get_targets`](#patchingget_targets): <code>get_targets()</code> except it also performs online checks and gathers facts in one step.
* [`patching::monitoring_solarwinds`](#patchingmonitoring_solarwinds): Creates or deletes VM snapshots on nodes in VMware.
* [`patching::ordered_groups`](#patchingordered_groups): Takes a set of targets then groups and sorts them by the <code>patching_order</code> var set on the target.
* [`patching::post_update`](#patchingpost_update): Executes a custom post-update script on each node.
* [`patching::pre_post_update`](#patchingpre_post_update): Common entry point for executing the pre/post update custom scripts
* [`patching::pre_update`](#patchingpre_update): Executes a custom pre-update script on each node.
* [`patching::puppet_facts`](#patchingpuppet_facts): Plan thatr runs 'puppet facts' on the nodes and sets them as facts on the Target objects.
* [`patching::reboot_required`](#patchingreboot_required): Querys a nodes operating system to determine if a reboot is required and then reboots the nodes that require rebooting.
* [`patching::snapshot_vmware`](#patchingsnapshot_vmware): Creates or deletes VM snapshots on nodes in VMware.
* [`patching::update_history`](#patchingupdate_history): Collect update history from the results JSON file on the targets

## Classes

### patching

allows global customization of the patching resources

#### Examples

##### Basic usage

```puppet
include patching
```

##### Customizing script location

```puppet
class {'patching':
  bin_dir => '/my/custom/patching/scripts',
}
```

##### Customizing the owner/group/mode of the scripts

```puppet
class {'patching':
  owner => 'svc_patching',
  group => 'svc_patching',
  mode  => '0700',
}
```

##### Customizing from hiera

```puppet
patching::bin_dir: '/my/custom/app/patching/dir'
patching::owner: 'svc_patching'
patching::group: 'svc_patching'
patching::mode: '0700'
```

##### Deploying scripts from hiera

```puppet
patching::scripts:
  custom_app_pre_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_pre_patch.sh'
  custom_app_post_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_post_patch.sh'
```

#### Parameters

The following parameters are available in the `patching` class.

##### `patching_dir`

Data type: `Any`

Global directory as the base for `bin_dir` and `log_dir`

Default value: $patching::params::patching_dir

##### `bin_dir`

Data type: `Any`

Global directory where the scripts will be installed

Default value: $patching::params::bin_dir

##### `log_dir`

Data type: `Any`

Directory where log files will be written during patching

Default value: $patching::params::log_dir

##### `owner`

Data type: `Any`

Default owner of installed scripts

Default value: $patching::params::owner

##### `group`

Data type: `Any`

Default group of installed scripts

Default value: $patching::params::group

##### `mode`

Data type: `Any`

Default file mode of installed scripts

Default value: $patching::params::mode

##### `scripts`

Data type: `Optional[Hash]`

Hash of script resources to instantiate. Useful for declaring script installs from hiera.

Default value: `undef`

### patching::params

params for the patching module resources

## Defined types

### patching::script

manages a script for custom patching actions

#### Examples

##### Basic usage from static file

```puppet
include patching
patching::script { 'pre_patch.sh':
  source => 'puppet://mymodule/patching/custom_app_pre_patch.sh',
}
```

##### Basic usage from template

```puppet
include patching
patching::script { 'pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
}
```

##### Installing the script into a different path with a different name

```puppet
include patching
patching::script { 'custom_app_pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
  bin_dir => '/my/custom/app/patching/dir',
}
```

##### Installing multiple scripts into a different path

```puppet
class {'patching':
  bin_dir => '/my/custom/app/patching/dir',
}

# we don't have to override bin_dir on each of these because
# we configured it gobally in the patching class above
patching::script { 'custom_app_pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
}
patching::script { 'custom_app_post_patch.sh':
  content => template('mymodule/patching/custom_app_post_patch.sh'),
}
```

##### From hiera

```puppet
patching::bin_dir: '/my/custom/app/patching/dir'
patching::scripts:
  custom_app_pre_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_pre_patch.sh'
  custom_app_post_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_post_patch.sh'
```

#### Parameters

The following parameters are available in the `patching::script` defined type.

##### `source`

Data type: `Any`

Source (puppet path) for the `file` resource of the script.
Either `source` our `content` must be specified. If neither are specified an error will be thrown.

Default value: `undef`

##### `content`

Data type: `Any`

Content (raw string, result of `template()`, etc) for the `file` resource of the script.
Either `source` our `content` must be specified. If neither are specified an error will be thrown.

Default value: `undef`

##### `bin_dir`

Data type: `Any`

Directory where the script will be installed

Default value: $patching::bin_dir

##### `owner`

Data type: `Any`

Owner of the script file

Default value: $patching::owner

##### `group`

Data type: `Any`

Group of the script file

Default value: $patching::group

##### `mode`

Data type: `Any`

File mode to set on the script

Default value: $patching::mode

## Functions

### patching::snapshot_vmware

Type: Ruby 4.x API

Creates/deletes snapshots on VMs using the VMware vSphere API.

#### `patching::snapshot_vmware(Array $vm_names, String $snapshot_name, String $vsphere_host, String $vsphere_username, String $vsphere_password, String $vsphere_datacenter, Optional[Boolean] $vsphere_insecure, Optional[String] $snapshot_description, Optional[Boolean] $snapshot_memory, Optional[Boolean] $snapshot_quiesce, Optional[String] $action)`

Creates/deletes snapshots on VMs using the VMware vSphere API.

Returns: `Array` Results from the snapshot create/delete tasks

##### `vm_names`

Data type: `Array`

Array of VM names to create/delete snapshots on

##### `snapshot_name`

Data type: `String`

Name of the snapshot to create/delete

##### `vsphere_host`

Data type: `String`

Hostname/IP of the vSphere server

##### `vsphere_username`

Data type: `String`

Username to use for authenticating to vSphere

##### `vsphere_password`

Data type: `String`

Password to use for authenticating to vSphere

##### `vsphere_datacenter`

Data type: `String`

Datacenter in the vSphere to use when search for VMs

##### `vsphere_insecure`

Data type: `Optional[Boolean]`

Flag to enable HTTPS without SSL verification

##### `snapshot_description`

Data type: `Optional[String]`

Description of the snapshot, when creating.

##### `snapshot_memory`

Data type: `Optional[Boolean]`

Snapshot the VMs memory, when creating.

##### `snapshot_quiesce`

Data type: `Optional[Boolean]`

Quiesce/flush the VMs filesystem when creating the snapshot

##### `action`

Data type: `Optional[String]`

Action to perform on the snapshot, 'create' or 'delete'

### patching::target_names

Type: Puppet Language

Returns an array of names, one for each target, based on the $name_property

#### `patching::target_names(TargetSpec $targets, Enum['name', 'uri'] $name_property)`

The patching::target_names function.

Returns: `Array[String]` Array of names, one for each target

##### `targets`

Data type: `TargetSpec`

List of targets to extract the name from

##### `name_property`

Data type: `Enum['name', 'uri']`

Property in the Target to use as the name

## Tasks

### available_updates

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### available_updates_linux

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### available_updates_windows

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### cache_remove

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### cache_remove_linux

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### cache_remove_windows

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### cache_update

Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** true

### cache_update_linux

Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** true

### cache_update_windows

Updates the targets update cache. For RHEL/CentOS this means a `yum makecache fast`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** true

### history

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/PuppetLabs/patching/patching.json

### monitoring_solarwinds

Enable or disable monitoring alerts on hosts in SolarWinds.

**Supports noop?** true

#### Parameters

##### `nodes`

Data type: `Array[String[1]]`

List of hostnames or IP addresses for nodes in SolarWinds that will have monitoring alerts either enabled or disabled.

##### `action`

Data type: `Enum['enable', 'disable']`

Action to perform on monitored nodes. 'enable' will enable monitoring alerts. 'disable' will disable monitoring alerts on nodes.

### post_update

Run post-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this allows us to run thist task on all hosts, even if they don't have a post-update script).

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/post_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/post_update.ps1.

### pre_post_update_linux

Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### pre_post_update_windows

Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### pre_update

Run pre-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this allows us to run thist task on all hosts, even if they don't have a pre-update script).

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### puppet_facts

Gather system facts using 'puppet facts'. Puppet agent MUST be installed for this to work.

**Supports noop?** false

### reboot_required

Checks if a reboot is pending

**Supports noop?** false

### reboot_required_linux

Checks if a reboot is pending

**Supports noop?** false

### reboot_required_windows

Checks if a reboot is pending

**Supports noop?** false

### update

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.log

### update_history

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/PuppetLabs/patching/patching.json

### update_history_linux

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/PuppetLabs/patching/patching.json

### update_history_windows

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/PuppetLabs/patching/patching.json

### update_linux

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.log

### update_windows

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/patching.log

## Plans

### patching

It serves as a showcase of how all of the building blocks in this module
can be tied together to create a full blown patching workflow.
This is a great initial workflow to patch servers.
We fully expect others to take this workflow as a build-block and customize
it to meet their needs.

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching --nodes linux_patching,windows_patching
```

##### CLI - Disable snapshot creation, because an old patching run failed and we have an old snapshot to rely on

```puppet
bolt plan run patching --nodes linux_patching,windows_patching snapshot_create=false
```

##### CLI - Disable snapshot deletion, because we want to wait for app teams to test.

```puppet
bolt plan run patching --nodes linux_patching,windows_patching snapshot_delete=true

# sometime in the future, delete the snapshots
bolt plan run patching::snapshot_vmare --nodes linux_patching,windows_patching action='delete'
```

##### CLI - Customize the pre/post update plans to use your own module's version

```puppet
bolt plan run patching --nodes linux_patching pre_update_plan='mymodule::pre_update' post_update_plan='mymodule::post_update'
```

#### Parameters

The following parameters are available in the `patching` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `filter_offline_nodes`

Data type: `Boolean`

Flag to determine if offline nodes should be filtered out of the list of targets
returned by this plan. If true, when running the <code>puppet_agent::version</code>
check, any nodes that return an error will be filtered out and ignored.
Those targets will not be returned in any of the data structures in the result of
this plan. If false, then any nodes that are offline will cause this plan to error
immediately when performing the online check. This will result in a halt of the
patching process.

Default value: `false`

##### `monitoring_plan`

Data type: `Optional[String]`

Name of the plan to use for disabling/enabling monitoring steps of the workflow.

Default value: 'patching::monitoring_solarwinds'

##### `pre_update_plan`

Data type: `String`

Name of the plan to use for executing the pre-update step of the workflow.

Default value: 'patching::pre_update'

##### `post_update_plan`

Data type: `String`

Name of the plan to use for executing the post-update step of the workflow.

Default value: 'patching::post_update'

##### `reboot_strategy`

Data type: `Enum['only_required', 'never', 'always']`

Determines the reboot strategy for the run.

 - 'only_required' only reboots hosts that require it based on info reported from the OS
 - 'never' never reboots the hosts
 - 'always' will reboot the host no matter what

Default value: 'only_required'

##### `reboot_message`

Data type: `String`

Message displayed to the user prior to the system rebooting

Default value: 'NOTICE: This system is currently being updated.'

##### `snapshot_plan`

Data type: `Optional[String]`

Name of the plan to use for executing snaphot creation and deletion steps of the workflow
You can also pass `''` or `undef'` as an easy way to disable both creation and deletion.

Default value: 'patching::snapshot_vmware'

##### `snapshot_create`

Data type: `Boolean`

Flag to enable/disable creating snapshots before patching groups.
A common usecase to disabling snapshot creation is that, say you run patching
with `snapshot_create` enabled and something goes wrong during patching and
the run fails. The sanpshot still exists and you want to retry patching
but don't want to create ANOTHER snapshot on top of the one we already have.
In this case we would pass in `snapshot_create=false` when running the second time.

Default value: `true`

##### `snapshot_delete`

Data type: `Boolean`

Flag to enable/disable deleting snapshots after patching groups.
A common usecase to disable snapshot deletion is that, say you want to patch your
hosts and wait a few hours for application teams to test after you're done patching.
In this case you can run with `snapshot_delete=false` and then a few hours later
you can run the `patching::snapshot_vmware action=delete` sometime in the future.

Default value: `true`

##### `noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: `false`

### patching::available_updates

This uses the <code>patching::available_updates</code> task to query each Target's
Operating System for available updates. The results from the OS are parsed and formatted
into easy to consume JSON data, such that further code can be written against the
output.

 - RHEL: This ultimately performs a <code>yum check-update</code>.
 - Ubuntu: This ultimately performs a <code>apt upgrade --simulate</code>.
 - Windows:
   - Windows Update API: Queries the WUA for updates. This is the standard update mechanism
     for Windows.
   - Chocolatey: If installed, runs <code>choco outdated</code>.
     If not installed, Chocolatey is ignored.

#### Examples

##### CLI - Basic Usage

```puppet
bolt plan run patching::available_updates --nodes linux_hosts
```

##### CLI - Get available update information in CSV format for creating reports

```puppet
bolt plan run patching::available_updates --nodes linux_hosts format=csv
```

##### Plan - Basic Usage

```puppet
run_plan('patching::available_updates',
         nodes => $linux_hosts)
```

##### Plan - Get available update information in CSV format for creating reports

```puppet
run_plan('patching::available_updates',
         nodes  => $linux_hosts,
         format => 'csv')
```

#### Parameters

The following parameters are available in the `patching::available_updates` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `format`

Data type: `Enum['none', 'pretty', 'csv']`

Output format for printing user-friendly information during the plan run.
This also determines the format of the information returned from this plan.

  - 'none' : Prints no data to the screen. Returns the raw ResultSet from
     the patching::available_updates task
  - 'pretty' : Prints the data out in a easy to consume format, one line per host,
     showing the number of available updates per host. Returns a Hash containing
     two keys: 'has_updates' - an array of TargetSpec that have updates available,
     'no_updates' - an array of hosts that have no updates available.
  - 'csv' : Prints and returns CSV formatted data, one row for each update of each host.

Default value: 'pretty'

##### `noop`

Data type: `Boolean`

Run this plan in noop mode, meaning no changes will be made to end systems.
In this case, noop mode has no effect.

Default value: `false`

### patching::check_online

Online checks are done querying for the node's Puppet version using the
<code>puppet_agent::version</code> task.
This plan is designed to be used ad-hoc as a quick health check of your inventory.
It is the intention of this plan to be used as "first pass" when onboarding new nodes
into a Bolt rotation.
One would build their inventory file of all nodes from their trusted data sources.
Then take the inventory files and run this plan against them to isolate problem nodes
and remediate them.
Once this plan runs successfuly on your inventory, you know that Bolt can connect
and can begin the patching proces.

There are no results returned by this plan, instead data is pretty-printed to the screen in
two lists:

  1. List of targets that failed to connect. This list is a YAML list where each line
     is the name of a Target that failed to connect.
     The intention here is that you can use this YAML list to modify your inventory
     and remove these problem hosts from your groups.
  2. Details for each failed target. This provides details about the error that
     occured when connecting. Failures can occur for many reasons, host being offline
     host not listening on the right port, firewall blocking, invalid credentials, etc.
     The idea here is to give the end-user a easily digestible summary so that action
     can be taken to remediate these hosts.

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::check_online
```

#### Parameters

The following parameters are available in the `patching::check_online` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

### patching::check_puppet

Executes the <code>puppet_agent::version</code> task to check if Puppet is installed
on all of the nodes. Once finished, the result is split into two groups:

 1. Nodes with puppet
 2. Nodes with no puppet

The nodes with puppet are queried for facts using the <code>patching::puppet_facts</code> plan.
Nodes without puppet are queried for facts using the simpler <code>facts</code> plan.

This plan is designed to be the first plan executed in a patching workflow.
It can be used to stop the patching process if any hosts are offline by setting
<code>filter_offline_nodes=false</code> (default). It can also be used
to patch any hosts that are currently available and ignoring any offline nodes
by setting <code>filter_offline_nodes=true</code>.

#### Examples

##### CLI - Basic usage (error if any nodes are offline)

```puppet
bolt plan run patching::check_puppet --nodes linux_hosts
```

##### CLI - Filter offline nodes (only return online nodes)

```puppet
bolt plan run patching::check_puppet --nodes linux_hosts filter_offline_nodes=true
```

##### Plan - Basic usage (error if any nodes are offline)

```puppet
$results = run_plan('patching::check_puppet',
                    nodes => $linux_hosts)
$targets_has_puppet = $results['has_puppet']
$targets_no_puppet = $results['no_puppet']
$targets_all = $results['all']
```

##### Plan - Filter offline nodes (only return online nodes)

```puppet
$results = run_plan('patching::check_puppet',
                    nodes                => $linux_hosts,
                    filter_offline_nodes => true)
$targets_online_has_puppet = $results['has_puppet']
$targets_online_no_puppet = $results['no_puppet']
$targets_online = $results['all']
```

#### Parameters

The following parameters are available in the `patching::check_puppet` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `filter_offline_nodes`

Data type: `Boolean`

Flag to determine if offline nodes should be filtered out of the list of targets
returned by this plan. If true, when running the <code>puppet_agent::version</code>
check, any nodes that return an error will be filtered out and ignored.
Those targets will not be returned in any of the data structures in the result of
this plan. If false, then any nodes that are offline will cause this plan to error
immediately when performing the online check. This will result in a halt of the
patching process.

Default value: `false`

### patching::deploy_scripts

The patching::deploy_scripts class.

#### Examples

##### CLI deploy a pre patching script

```puppet
bolt plan run patching::deploy_scripts scripts='{"pre_patch.sh": {"source": "puppet:///modules/test/patching/pre_patch.sh"}}'
```

##### CLI deploy a pre and post patching script

```puppet
bolt plan run patching::deploy_scripts scripts='{"pre_patch.sh": {"source": "puppet:///modules/test/patching/pre_patch.sh"}, "post_patch.sh": {"source": "puppet:///modules/test/patching/post_patch.sh"}}'
```

#### Parameters

The following parameters are available in the `patching::deploy_scripts` plan.

##### `owner`

Data type: `Optional[String]`

Default owner of installed scripts

Default value: `undef`

##### `group`

Data type: `Optional[String]`

Default group of installed scripts

Default value: `undef`

##### `mode`

Data type: `Optional[String]`

Default file mode of installed scripts

Default value: `undef`

##### `nodes`

Data type: `TargetSpec`



##### `scripts`

Data type: `Hash`



##### `patching_dir`

Data type: `Optional[String]`



Default value: `undef`

##### `bin_dir`

Data type: `Optional[String]`



Default value: `undef`

##### `log_dir`

Data type: `Optional[String]`



Default value: `undef`

### patching::get_targets

A very common requirement when running individual plans from the commandline is that
each plan would need to perform the following steps:
 - Convert the TargetSpec from a string into an Array[Target] using <code>get_targets($nodes)</code>
 - Check for nodes that are online (calls plan <code>patching::check_puppet</code>
 - Gather facts about the nodes

This plan combines all of that into one so that it can be reused in all of the other
plans within this module. It also adds some smart checking so that, if multiple plans
invoke each other, each of which call this plan. The online check and facts gathering
only hapens once.

#### Examples

##### Plan - Basic usage

```puppet
plan mymodule::myplan (
  TargetSpec $nodes
) {
  $targets = run_plan('patching::get_targets', nodes => $ndoes)
  # do normal stuff with your $targets
}
```

#### Parameters

The following parameters are available in the `patching::get_targets` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

### patching::monitoring_solarwinds

Communicates to the vSphere API from the local Bolt control node using
the [rbvmomi](https://github.com/vmware/rbvmomi) Ruby gem.

To install the rbvmomi gem on the bolt control node:
```shell
  /opt/puppetlabs/bolt/bin/gem install --user-install rbvmomi
```

TODO config variables

#### Examples

##### Remote target definition for $monitoring_target

```puppet
vars:
  patching_monitoring_plan: 'patching::monitoring_solarwinds'
  patching_monitoring_target: 'solarwinds'

groups:
  - name: solarwinds
    config:
      transport: remote
      remote:
        port: 17778
        username: 'domain\svc_bolt_sw'
        password:
          _plugin: pkcs7
          encrypted_value: >
            ENC[PKCS7,xxx]
    targets:
      - solawrinds.domain.tld
```

#### Parameters

The following parameters are available in the `patching::monitoring_solarwinds` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `action`

Data type: `Enum['enable', 'disable']`

What action to perform on the monitored nodes:

  - `enable` Resumes monitoring alerts
  - 'disable' Supresses monitoring alerts

##### `target_name_property`

Data type: `Optional[Enum['name', 'uri']]`

Determines what property on the Target object will be used as the name when
mapping the Target to a Node in SolarWinds.

 - `uri` : use the `uri` property on the Target. This is preferred because
    If you specify a list of Targets in the inventory file, the value shown in that
    list is set as the `uri` and not the `name`, in this case `name` will be `undef`.
 - `name` : use the `name` property on the Target, this is not preferred because
    `name` is usually a short name or nickname.

Default value: `undef`

##### `monitoring_target`

Data type: `TargetSpec`

Name or reference to the remote transport target of the Monitoring server.
This will be used when to determine how to communicate with the SolarWinds API.
The remote transport should have the following properties:
  - [Integer] port
      Port to use when communicating with SolarWinds API (default: 17778)
  - [String] username
      Username for authenticating with the SolarWinds API
  - [Password] password
      Password for authenticating with the SolarWinds API

Default value: .vars['patching_monitoring_target']

##### `noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: `false`

### patching::ordered_groups

When patching hosts it is common that you don't want to patch them all at the same time,
for obvious reasons. To facilitate this we devised the concept of a "patching order".
Patching order is a mechanism to allow nodes to be organized into groups and
then sorted so that a custom order can be defined for your specific usecase.

The way one assigns a patching order to a target or group is using <code>vars</code>
in the Bolt inventory file.

Example:

```yaml
---
groups:
  - name: primary_nodes
    vars:
      patching_order: 1
    targets:
      - sql01.domain.tld

  - name: backup_nodes
    vars:
      patching_order: 2
    targets:
      - sql02.domain.tld
```

When the <code>patching_order</code> is defined at the group level, it is inherited
by all nodes within that group.

The reason this plan exists is that there is no concept of a "group" in the bolt
runtime, so we need to artificially recreate them using our <code>patching_order</code>
vars paradigm.

An added benefit to this paradigm is that you may have grouped your nodes logically
on a different dimension, say by application. If it's OK that multiple applications be
patched at the same time, we can assign the same patching order to multiple groups
in the inventory. Then, when run through this plan, they will be aggregated together
into one large group of nodes that will all be patched concurrently.

Example, app_xxx and app_zzz both can be patched at the same time, but app_yyy needs to go
later in the process:

```yaml
---
groups:
  - name: app_xxx
    vars:
      patching_order: 1
    targets:
      - xxx

  - name: app_yyy
    vars:
      patching_order: 2
    targets:
      - yyy

  - name: app_zzz
    vars:
      patching_order: 1
    targets:
      - zzz
```

 This is returned as an Array, because an Array has a defined order when
 you iterate over it using <code>.each</code>. Ordering is important in patching
 so we wanted this to be very concrete.

#### Examples

##### Basic usage

```puppet
$ordered_groups = run_plan('patching::ordered_groups', nodes => $targets)
$ordered_groups.each |$group_hash| {
  $group_order = $group_hash['order']
  $group_nodes = $group_hash['nodes']
  # run your patching process for the group
}
```

#### Parameters

The following parameters are available in the `patching::ordered_groups` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to created ordered groups of.

### patching::post_update

Often in patching it is necessary to run custom commands before/after updates are
applied to a host. This plan allows for that customization to occur.

By default it executes a Shell script on Linux and a PowerShell script on Windows hosts.
The default script paths are:
  - Linux: `/opt/patching/bin/post_update.sh`
  - Windows: `C:\ProgramData\patching\bin\post_update.ps1`

One can customize the script paths by overriding them on the CLI, or when calling the plan
using the `script_linux` and `script_windows` parameters.

The script paths can also be customzied in the inventory configuration `vars`:
Example:

``` yaml
vars:
  patching_post_update_script_windows: C:\scripts\patching.ps1
  patching_post_update_script_linux: /usr/local/bin/mysweetpatchingscript.sh

groups:
  # these nodes will use the pre patching script defined in the vars above
  - name: regular_nodes
    targets:
      - tomcat01.domain.tld

  # these nodes will use the customized patching script set for this group
  - name: sql_nodes
    vars:
      patching_post_update_script_linux: /bin/sqlpatching.sh
    targets:
      - sql01.domain.tld
```

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::post_update --nodes all_hosts
```

##### CLI - Custom scripts

```puppet
bolt plan run patching::post_update --nodes all_hosts script_linux='/my/sweet/script.sh' script_windows='C:\my\sweet\script.ps1'
```

##### Plan - Basic usage

```puppet
run_plan('patching::post_update',
         nodes => $all_hosts)
```

##### Plan - Custom scripts

```puppet
run_plan('patching::post_update',
         nodes          => $all_hosts,
         script_linux   => '/my/sweet/script.sh',
         script_windows => 'C:\my\sweet\script.ps1')
```

#### Parameters

The following parameters are available in the `patching::post_update` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `script_linux`

Data type: `String[1]`

Path to the script that will be executed on Linux nodes.

Default value: '/opt/patching/bin/post_update.sh'

##### `script_windows`

Data type: `String[1]`

Path to the script that will be executed on Windows nodes.

Default value: 'C:\ProgramData\patching\bin\post_update.ps1'

##### `noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: `false`

### patching::pre_post_update

Common entry point for executing the pre/post update custom scripts

* **See also**
patching::pre_update
patching::post_update

#### Parameters

The following parameters are available in the `patching::pre_post_update` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `task`

Data type: `String[1]`

Name of the pre/post update task to execute.

##### `script_linux`

Data type: `Optional[String[1]]`

Path to the script that will be executed on Linux nodes.

Default value: `undef`

##### `script_windows`

Data type: `Optional[String[1]]`

Path to the script that will be executed on Windows nodes.

Default value: `undef`

##### `noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: `false`

### patching::pre_update

Often in patching it is necessary to run custom commands before/after updates are
applied to a host. This plan allows for that customization to occur.

By default it executes a Shell script on Linux and a PowerShell script on Windows hosts.
The default script paths are:
  - Linux: `/opt/patching/bin/pre_update.sh`
  - Windows: `C:\ProgramData\patching\bin\pre_update.ps1`

One can customize the script paths by overriding them on the CLI, or when calling the plan
using the `script_linux` and `script_windows` parameters.

The script paths can also be customzied in the inventory configuration `vars`:
Example:

``` yaml
vars:
  patching_pre_update_script_windows: C:\scripts\patching.ps1
  patching_pre_update_script_linux: /usr/local/bin/mysweetpatchingscript.sh

groups:
  # these nodes will use the pre patching script defined in the vars above
  - name: regular_nodes
    targets:
      - tomcat01.domain.tld

  # these nodes will use the customized patching script set for this group
  - name: sql_nodes
    vars:
      patching_pre_update_script_linux: /bin/sqlpatching.sh
    targets:
      - sql01.domain.tld
```

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::pre_update --nodes all_hosts
```

##### CLI - Custom scripts

```puppet
bolt plan run patching::pre_update --nodes all_hosts script_linux='/my/sweet/script.sh' script_windows='C:\my\sweet\script.ps1'
```

##### Plan - Basic usage

```puppet
run_plan('patching::pre_update',
         nodes => $all_hosts)
```

##### Plan - Custom scripts

```puppet
run_plan('patching::pre_update',
         nodes          => $all_hosts,
         script_linux   => '/my/sweet/script.sh',
         script_windows => 'C:\my\sweet\script.ps1')
```

#### Parameters

The following parameters are available in the `patching::pre_update` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `script_linux`

Data type: `String[1]`

Path to the script that will be executed on Linux nodes.

Default value: '/opt/patching/bin/pre_update.sh'

##### `script_windows`

Data type: `String[1]`

Path to the script that will be executed on Windows nodes.

Default value: 'C:\ProgramData\patching\bin\pre_update.ps1'

##### `noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: `false`

### patching::puppet_facts

This is inspired by: https://github.com/puppetlabs/puppetlabs-facts/blob/master/plans/init.pp
Except instead of just running `facter` it runs `puppet facts` to set additional
facts that are only present when in the context of puppet.

Under the hood it is executeing the `patching::puppet_facts` task.

#### Parameters

The following parameters are available in the `patching::puppet_facts` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

### patching::reboot_required

Patching in different environments comes with various unique requirements, one of those
is rebooting hosts. Sometimes hosts need to always be reboot, othertimes never rebooted.

To provide this flexibility we created this function that wraps the `reboot` plan with
a `strategy` that is controllable as a parameter. This provides flexibilty in
rebooting specific nodes in certain ways (by group). Along with the power to expand
our strategy offerings in the future.

#### Parameters

The following parameters are available in the `patching::reboot_required` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `strategy`

Data type: `Enum['only_required', 'never', 'always']`

Determines the reboot strategy for the run.

 - 'only_required' only reboots hosts that require it based on info reported from the OS
 - 'never' never reboots the hosts
 - 'always' will reboot the host no matter what

Default value: 'only_required'

##### `message`

Data type: `String`

Message displayed to the user prior to the system rebooting

Default value: 'NOTICE: This system is currently being updated.'

##### `noop`

Data type: `Boolean`

Flag to determine if this should be a noop operation or not.
If this is a noop, no hosts will ever be rebooted, however the "reboot required" information
will still be queried and returned.

Default value: `false`

### patching::snapshot_vmware

Communicates to the vSphere API from the local Bolt control node using
the [rbvmomi](https://github.com/vmware/rbvmomi) Ruby gem.

To install the rbvmomi gem on the bolt control node:
```shell
  /opt/puppetlabs/bolt/bin/gem install --user-install rbvmomi
```

TODO config variables

#### Parameters

The following parameters are available in the `patching::snapshot_vmware` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `action`

Data type: `Enum['create', 'delete']`

What action to perform on the snapshots:

  - `create` creates a new snapshot
  - 'delete' deletes snapshots by matching the `snapshot_name` passed in.

##### `target_name_property`

Data type: `Optional[Enum['name', 'uri']]`

Determines what property on the Target object will be used as the VM name when
mapping the Target to a VM in vSphere.

 - `uri` : use the `uri` property on the Target. This is preferred because
    If you specify a list of Targets in the inventory file, the value shown in that
    list is set as the `uri` and not the `name`, in this case `name` will be `undef`.
 - `name` : use the `name` property on the Target, this is not preferred because
    `name` is usually a short name or nickname.

Default value: `undef`

##### `vsphere_host`

Data type: `String[1]`

Hostname of the vSphere server that we're going to use to create snapshots via the API.

Default value: .vars['vsphere_host']

##### `vsphere_username`

Data type: `String[1]`

Username to use when authenticating with the vSphere API.

Default value: .vars['vsphere_username']

##### `vsphere_password`

Data type: `String[1]`

Password to use when authenticating with the vSphere API.

Default value: .vars['vsphere_password']

##### `vsphere_datacenter`

Data type: `String[1]`

Name of the vSphere datacenter to search for VMs under.

Default value: .vars['vsphere_datacenter']

##### `vsphere_insecure`

Data type: `Boolean`

Flag to enable insecure HTTPS connections by disabling SSL server certificate verification.

Default value: .vars['vsphere_insecure']

##### `snapshot_name`

Data type: `String[1]`

Name of the snapshot

Default value: 'Bolt Patching Snapshot'

##### `snapshot_description`

Data type: `String`

Description of the snapshot

Default value: ''

##### `snapshot_memory`

Data type: `Boolean`

Capture the VMs memory in the snapshot

Default value: `false`

##### `snapshot_quiesce`

Data type: `Boolean`

Quiesce/flush the filesystem when snapshotting the VM. This requires VMware tools be installed
in the guest OS to work properly.

Default value: `true`

##### `noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: `false`

### patching::update_history

When executing the `patching::update` task, the data that is returned to Bolt
is also written into a "results" file. This plan reads the last JSON document
from that results file, then formats the results in various ways.

This is useful for gather patching report data on a fleet of servers.

If you're using this in a larger workflow and you've run `patching::update` inline.
You can pass the ResultSet from that task into the `history` parameter of this
plan and we will skip retrieving the history from the targets and simply use
that data.

#### Parameters

The following parameters are available in the `patching::update_history` plan.

##### `nodes`

Data type: `TargetSpec`

Set of targets to run against.

##### `history`

Data type: `Optional[ResultSet]`

Optional ResultSet from the `patching::update` or `patching::update_history` tasks
that contains update result data to be formatted.

Default value: `undef`

##### `report_file`

Data type: `Optional[String]`

Optional filename to save the formatted repot into.
If `undef` is passed, then no report file will be written.

Default value: 'patching_report.csv'

##### `format`

Data type: `Enum['none', 'pretty', 'csv']`

The method of formatting to use for the data.

Default value: 'pretty'

