# Reference

<!-- DO NOT EDIT: This document was generated by Puppet Strings -->

## Table of Contents

### Classes

* [`patching`](#patching): allows global customization of the patching resources
* [`patching::params`](#patchingparams): params for the patching module resources

### Defined types

* [`patching::script`](#patchingscript): manages a script for custom patching actions

### Functions

* [`patching::snapshot_vmware`](#patchingsnapshot_vmware): Creates/deletes snapshots on VMs using the VMware vSphere API.
* [`patching::target_names`](#patchingtarget_names): Returns an array of names, one for each target, based on the $name_property

### Tasks

* [`available_updates`](#available_updates): Collects information about available updates on a target system
* [`available_updates_linux`](#available_updates_linux): Collects information about available updates on a target system
* [`available_updates_windows`](#available_updates_windows): Collects information about available updates on a target system
* [`cache_remove`](#cache_remove): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_remove_linux`](#cache_remove_linux): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_remove_windows`](#cache_remove_windows): Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows thi
* [`cache_update`](#cache_update): Updates the targets update cache. For RHEL/CentOS this means a `yum clean expire-cache`. For Debian this means a `apt update`. For Windows th
* [`cache_update_linux`](#cache_update_linux): Updates the targets update cache. For RHEL/CentOS this means a `yum clean expire-cache`. For Debian this means a `apt update`.
* [`cache_update_windows`](#cache_update_windows): Updates the targets update cache. For Windows this means a Windows Update refresh.
* [`history`](#history): Reads the update history from the JSON 'result_file'.
* [`monitoring_prometheus`](#monitoring_prometheus): Create or remove alert silences for hosts in Prometheus.
* [`monitoring_solarwinds`](#monitoring_solarwinds): Enable or disable monitoring alerts on hosts in SolarWinds.
* [`post_update`](#post_update): Run post-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this a
* [`pre_post_update_linux`](#pre_post_update_linux): Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.
* [`pre_post_update_windows`](#pre_post_update_windows): Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.
* [`pre_update`](#pre_update): Run pre-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this al
* [`puppet_facts`](#puppet_facts): Gather system facts using 'puppet facts'. Puppet agent MUST be installed for this to work.
* [`reboot_required`](#reboot_required): Checks if a reboot is pending
* [`reboot_required_linux`](#reboot_required_linux): Checks if a reboot is pending
* [`reboot_required_windows`](#reboot_required_windows): Checks if a reboot is pending
* [`snapshot_kvm`](#snapshot_kvm): Creates or deletes snapshots on a set of KVM/Libvirt hypervisors
* [`update`](#update): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windo
* [`update_history`](#update_history): Reads the update history from the JSON 'result_file'.
* [`update_history_linux`](#update_history_linux): Reads the update history from the JSON 'result_file'.
* [`update_history_windows`](#update_history_windows): Reads the update history from the JSON 'result_file'.
* [`update_linux`](#update_linux): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For SLES this runs `zypper 
* [`update_windows`](#update_windows): Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windo

### Plans

* [`patching`](#patching): Our generic and semi-opinionated workflow.
* [`patching::available_updates`](#patchingavailable_updates): Checks all targets for available updates reported by their Operating System.
* [`patching::check_online`](#patchingcheck_online): Checks each node to see they're online.
* [`patching::check_puppet`](#patchingcheck_puppet): Checks each node to see if Puppet is installed, then gather Facts on all targets.
* [`patching::deploy_scripts`](#patchingdeploy_scripts)
* [`patching::get_facts`](#patchingget_facts): Sets patching facts on targets
* [`patching::get_targets`](#patchingget_targets): <code>get_targets()</code> except it also performs online checks and gathers facts in one step.
* [`patching::monitoring_multiple`](#patchingmonitoring_multiple): Disable monitoring for targets in multiple services
* [`patching::monitoring_prometheus`](#patchingmonitoring_prometheus): Create or remove alert silences for hosts in Prometheus.
* [`patching::monitoring_solarwinds`](#patchingmonitoring_solarwinds): Enable or disable monitoring alerts on hosts in SolarWinds.
* [`patching::ordered_groups`](#patchingordered_groups): Takes a set of targets then groups and sorts them by the <code>patching_order</code> var set on the target.
* [`patching::post_update`](#patchingpost_update): Executes a custom post-update script on each node.
* [`patching::pre_post_update`](#patchingpre_post_update): Common entry point for executing the pre/post update custom scripts
* [`patching::pre_update`](#patchingpre_update): Executes a custom pre-update script on each node.
* [`patching::puppet_facts`](#patchingpuppet_facts): Plan thatr runs 'puppet facts' on the targets and sets them as facts on the Target objects.
* [`patching::reboot_required`](#patchingreboot_required): Querys a targets operating system to determine if a reboot is required and then reboots the targets that require rebooting.
* [`patching::set_facts`](#patchingset_facts): Sets patching facts on targets
* [`patching::snapshot_kvm`](#patchingsnapshot_kvm): Creates or deletes VM snapshots on targets in KVM/Libvirt.
* [`patching::snapshot_vmware`](#patchingsnapshot_vmware): Creates or deletes VM snapshots on targets in VMware.
* [`patching::update_history`](#patchingupdate_history): Collect update history from the results JSON file on the targets

## Classes

### <a name="patching"></a>`patching`

allows global customization of the patching resources

#### Examples

##### Basic usage

```puppet
include patching
```

##### Customizing script location

```puppet
class {'patching':
  bin_dir => '/my/custom/patching/scripts',
}
```

##### Customizing the owner/group/mode of the scripts

```puppet
class {'patching':
  owner => 'svc_patching',
  group => 'svc_patching',
  mode  => '0700',
}
```

##### Customizing from hiera

```puppet
patching::bin_dir: '/my/custom/app/patching/dir'
patching::owner: 'svc_patching'
patching::group: 'svc_patching'
patching::mode: '0700'
```

##### Deploying scripts from hiera

```puppet
patching::scripts:
  custom_app_pre_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_pre_patch.sh'
  custom_app_post_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_post_patch.sh'
```

#### Parameters

The following parameters are available in the `patching` class:

* [`patching_dir`](#patching_dir)
* [`bin_dir`](#bin_dir)
* [`log_dir`](#log_dir)
* [`owner`](#owner)
* [`group`](#group)
* [`mode`](#mode)
* [`scripts`](#scripts)

##### <a name="patching_dir"></a>`patching_dir`

Data type: `Any`

Global directory as the base for `bin_dir` and `log_dir`

Default value: `$patching::params::patching_dir`

##### <a name="bin_dir"></a>`bin_dir`

Data type: `Any`

Global directory where the scripts will be installed

Default value: `$patching::params::bin_dir`

##### <a name="log_dir"></a>`log_dir`

Data type: `Any`

Directory where log files will be written during patching

Default value: `$patching::params::log_dir`

##### <a name="owner"></a>`owner`

Data type: `Any`

Default owner of installed scripts

Default value: `$patching::params::owner`

##### <a name="group"></a>`group`

Data type: `Any`

Default group of installed scripts

Default value: `$patching::params::group`

##### <a name="mode"></a>`mode`

Data type: `Any`

Default file mode of installed scripts

Default value: `$patching::params::mode`

##### <a name="scripts"></a>`scripts`

Data type: `Optional[Hash]`

Hash of script resources to instantiate. Useful for declaring script installs from hiera.

Default value: ``undef``

### <a name="patchingparams"></a>`patching::params`

params for the patching module resources

## Defined types

### <a name="patchingscript"></a>`patching::script`

manages a script for custom patching actions

#### Examples

##### Basic usage from static file

```puppet
include patching
patching::script { 'pre_patch.sh':
  source => 'puppet://mymodule/patching/custom_app_pre_patch.sh',
}
```

##### Basic usage from template

```puppet
include patching
patching::script { 'pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
}
```

##### Installing the script into a different path with a different name

```puppet
include patching
patching::script { 'custom_app_pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
  bin_dir => '/my/custom/app/patching/dir',
}
```

##### Installing multiple scripts into a different path

```puppet
class {'patching':
  bin_dir => '/my/custom/app/patching/dir',
}

# we don't have to override bin_dir on each of these because
# we configured it gobally in the patching class above
patching::script { 'custom_app_pre_patch.sh':
  content => template('mymodule/patching/custom_app_pre_patch.sh'),
}
patching::script { 'custom_app_post_patch.sh':
  content => template('mymodule/patching/custom_app_post_patch.sh'),
}
```

##### From hiera

```puppet
patching::bin_dir: '/my/custom/app/patching/dir'
patching::scripts:
  custom_app_pre_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_pre_patch.sh'
  custom_app_post_patch.sh:
    source: 'puppet:///mymodule/patching/custom_app_post_patch.sh'
```

#### Parameters

The following parameters are available in the `patching::script` defined type:

* [`source`](#source)
* [`content`](#content)
* [`bin_dir`](#bin_dir)
* [`owner`](#owner)
* [`group`](#group)
* [`mode`](#mode)

##### <a name="source"></a>`source`

Data type: `Any`

Source (puppet path) for the `file` resource of the script.
Either `source` our `content` must be specified. If neither are specified an error will be thrown.

Default value: ``undef``

##### <a name="content"></a>`content`

Data type: `Any`

Content (raw string, result of `template()`, etc) for the `file` resource of the script.
Either `source` our `content` must be specified. If neither are specified an error will be thrown.

Default value: ``undef``

##### <a name="bin_dir"></a>`bin_dir`

Data type: `Any`

Directory where the script will be installed

Default value: `$patching::bin_dir`

##### <a name="owner"></a>`owner`

Data type: `Any`

Owner of the script file

Default value: `$patching::owner`

##### <a name="group"></a>`group`

Data type: `Any`

Group of the script file

Default value: `$patching::group`

##### <a name="mode"></a>`mode`

Data type: `Any`

File mode to set on the script

Default value: `$patching::mode`

## Functions

### <a name="patchingsnapshot_vmware"></a>`patching::snapshot_vmware`

Type: Ruby 4.x API

Creates/deletes snapshots on VMs using the VMware vSphere API.

#### `patching::snapshot_vmware(Array $vm_names, String $snapshot_name, String $vsphere_host, String $vsphere_username, String $vsphere_password, String $vsphere_datacenter, Optional[Boolean] $vsphere_insecure, Optional[String] $snapshot_description, Optional[Boolean] $snapshot_memory, Optional[Boolean] $snapshot_quiesce, Optional[String] $action)`

Creates/deletes snapshots on VMs using the VMware vSphere API.

Returns: `Array` Results from the snapshot create/delete tasks

##### `vm_names`

Data type: `Array`

Array of VM names to create/delete snapshots on

##### `snapshot_name`

Data type: `String`

Name of the snapshot to create/delete

##### `vsphere_host`

Data type: `String`

Hostname/IP of the vSphere server

##### `vsphere_username`

Data type: `String`

Username to use for authenticating to vSphere

##### `vsphere_password`

Data type: `String`

Password to use for authenticating to vSphere

##### `vsphere_datacenter`

Data type: `String`

Datacenter in the vSphere to use when search for VMs

##### `vsphere_insecure`

Data type: `Optional[Boolean]`

Flag to enable HTTPS without SSL verification

##### `snapshot_description`

Data type: `Optional[String]`

Description of the snapshot, when creating.

##### `snapshot_memory`

Data type: `Optional[Boolean]`

Snapshot the VMs memory, when creating.

##### `snapshot_quiesce`

Data type: `Optional[Boolean]`

Quiesce/flush the VMs filesystem when creating the snapshot

##### `action`

Data type: `Optional[String]`

Action to perform on the snapshot, 'create' or 'delete'

### <a name="patchingtarget_names"></a>`patching::target_names`

Type: Puppet Language

Returns an array of names, one for each target, based on the $name_property

#### `patching::target_names(TargetSpec $targets, Enum['hostname', 'name', 'uri'] $name_property)`

The patching::target_names function.

Returns: `Array[String]` Array of names, one for each target

##### `targets`

Data type: `TargetSpec`

List of targets to extract the name from

##### `name_property`

Data type: `Enum['hostname', 'name', 'uri']`

Property in the Target to use as the name

## Tasks

### <a name="available_updates"></a>`available_updates`

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String]`

What update provider to use. For Linux (RHEL, Debian, SUSE, etc.) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### <a name="available_updates_linux"></a>`available_updates_linux`

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### <a name="available_updates_windows"></a>`available_updates_windows`

Collects information about available updates on a target system

**Supports noop?** true

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

### <a name="cache_remove"></a>`cache_remove`

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### <a name="cache_remove_linux"></a>`cache_remove_linux`

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### <a name="cache_remove_windows"></a>`cache_remove_windows`

Removes/clears the target's update cache. For RHEL/CentOS this means a `yum clean all`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** false

### <a name="cache_update"></a>`cache_update`

Updates the targets update cache. For RHEL/CentOS this means a `yum clean expire-cache`. For Debian this means a `apt update`. For Windows this means a Windows Update refresh.

**Supports noop?** true

### <a name="cache_update_linux"></a>`cache_update_linux`

Updates the targets update cache. For RHEL/CentOS this means a `yum clean expire-cache`. For Debian this means a `apt update`.

**Supports noop?** true

### <a name="cache_update_windows"></a>`cache_update_windows`

Updates the targets update cache. For Windows this means a Windows Update refresh.

**Supports noop?** true

### <a name="history"></a>`history`

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/PuppetLabs/patching/patching.json

### <a name="monitoring_prometheus"></a>`monitoring_prometheus`

Create or remove alert silences for hosts in Prometheus.

**Supports noop?** true

#### Parameters

##### `targets`

Data type: `Variant[String[1], Array[String[1]]]`

List of hostnames for targets in Prometheus that will have monitoring alerts either enabled or disabled.

##### `action`

Data type: `Enum['enable', 'disable']`

Action to perform on monitored targets. 'enable' will enable monitoring alerts. 'disable' will disable monitoring alerts on targets.

##### `prometheus_server`

Data type: `String[1]`

FQDN of the Prometheus server to create an alert silence for

##### `silence_duration`

Data type: `Optional[Integer]`

How long the alert silence will be alive for

##### `silence_units`

Data type: `Optional[Enum['minutes', 'hours', 'days', 'weeks']]`

Goes with the silence duration to determine how long the alert silence will be alive for

### <a name="monitoring_solarwinds"></a>`monitoring_solarwinds`

Enable or disable monitoring alerts on hosts in SolarWinds.

**Supports noop?** true

#### Parameters

##### `targets`

Data type: `Variant[String[1], Array[String[1]]]`

List of hostnames or IP addresses for targets in SolarWinds that will have monitoring alerts either enabled or disabled.

##### `name_property`

Data type: `Optional[String[1]]`

Property to use when looking up an Orion.Node in SolarWinds from a Bolt::Target. By default we check to see if the node is an IP address, if it is then we use the 'IPAddress' property, otherwise we use 'DNS'. If you want to change what the 'other' property is when the node name isn't an IP address, then specify this property.

##### `action`

Data type: `Enum['enable', 'disable']`

Action to perform on monitored targets. 'enable' will enable monitoring alerts. 'disable' will disable monitoring alerts on targets.

### <a name="post_update"></a>`post_update`

Run post-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this allows us to run thist task on all hosts, even if they don't have a post-update script).

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/post_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/post_update.ps1.

### <a name="pre_post_update_linux"></a>`pre_post_update_linux`

Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### <a name="pre_post_update_windows"></a>`pre_post_update_windows`

Pre-post-update definition to make bolt not throw a warning. Best to use pre_update or post_update directly.

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### <a name="pre_update"></a>`pre_update`

Run pre-update script on target host(s), only if it exists. If the script doesn't exist or isn't executable, then this task succeeds (this allows us to run thist task on all hosts, even if they don't have a pre-update script).

**Supports noop?** true

#### Parameters

##### `script`

Data type: `Optional[String[1]]`

Absolute path of the script to execute. If no script name is passed on Linux hosts a default is used: /opt/patching/bin/pre_update.sh. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/bin/pre_update.ps1.

### <a name="puppet_facts"></a>`puppet_facts`

Gather system facts using 'puppet facts'. Puppet agent MUST be installed for this to work.

**Supports noop?** false

### <a name="reboot_required"></a>`reboot_required`

Checks if a reboot is pending

**Supports noop?** false

### <a name="reboot_required_linux"></a>`reboot_required_linux`

Checks if a reboot is pending

**Supports noop?** false

### <a name="reboot_required_windows"></a>`reboot_required_windows`

Checks if a reboot is pending

**Supports noop?** false

### <a name="snapshot_kvm"></a>`snapshot_kvm`

Creates or deletes snapshots on a set of KVM/Libvirt hypervisors

**Supports noop?** true

#### Parameters

##### `vm_names`

Data type: `Variant[String[1], Array[String[1]]]`

List of VM names, in KVM/Libvirt these are called domains.

##### `snapshot_name`

Data type: `Optional[String[1]]`

Name of the snapshot

##### `snapshot_description`

Data type: `Optional[String[1]]`

Description of the snapshot

##### `snapshot_memory`

Data type: `Optional[Boolean]`

Snapshot the VMs memory

##### `snapshot_quiesce`

Data type: `Optional[Boolean]`

Quiesce the filesystem during the snapshot, can be a PITA.

##### `action`

Data type: `Enum['create', 'delete']`

Action to perform on the snapshots. 'create' will create new snapshots on the VMs. 'delete' will delete snapshots on the VMs.

### <a name="update"></a>`update`

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.log

### <a name="update_history"></a>`update_history`

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

### <a name="update_history_linux"></a>`update_history_linux`

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

### <a name="update_history_windows"></a>`update_history_windows`

Reads the update history from the JSON 'result_file'.

**Supports noop?** false

#### Parameters

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. This is data that was written by patching::update. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

### <a name="update_linux"></a>`update_linux`

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For SLES this runs `zypper up`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, SUSE, etc.) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, SLES = /var/log/zypp/history, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.log

### <a name="update_windows"></a>`update_windows`

Execute OS updates on the target. For RedHat/CentOS this runs `yum update`. For Debian/Ubuntu runs `apt upgrade`. For Windows this runs Windows Update and `choco update`.

**Supports noop?** false

#### Parameters

##### `provider`

Data type: `Optional[String[1]]`

What update provider to use. For Linux (RHEL, Debian, etc) this parameter is not used. For Windows the available values are: 'windows', 'chocolatey', 'all' (both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all' is passed and Chocolatey isn't installed then Chocolatey will simply be skipped. If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

##### `names`

Data type: `Optional[Array[String]]`

Name of the package(s) to update. If nothing is passed then all packages will be updated. Note: this currently only works for Linux, Windows support will be added in the future for both Windows Update and Chocolatey (TODO)

##### `result_file`

Data type: `Optional[String[1]]`

Log file for patching results. This file will contain the JSON output that is returned from these tasks. The data is written to a log file so that you can collect it later by running patching::history. If no script name is passed on Linux hosts a default is used: /var/log/patching.json. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.json

##### `log_file`

Data type: `Optional[String[1]]`

Log file for OS specific output during the patching process. This file will contain OS specific (RHEL/CentOS = yum history, Debian/Ubuntu = /var/log/apt/history.log, Windows = ??) data that this task used to generate its output. If no script name is passed on Linux hosts a default is used: /var/log/patching.log. If no script name is passed  on Windows hosts a default is used: C:/ProgramData/patching/log/patching.log

## Plans

### <a name="patching"></a>`patching`

It serves as a showcase of how all of the building blocks in this module
can be tied together to create a full blown patching workflow.
This is a great initial workflow to patch servers.
We fully expect others to take this workflow as a build-block and customize
it to meet their needs.

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching --targets linux_patching,windows_patching
```

##### CLI - Disable snapshot creation, because an old patching run failed and we have an old snapshot to rely on

```puppet
bolt plan run patching --targets linux_patching,windows_patching snapshot_create=false
```

##### CLI - Disable snapshot deletion, because we want to wait for app teams to test.

```puppet
bolt plan run patching --targets linux_patching,windows_patching snapshot_delete=true

# sometime in the future, delete the snapshots
bolt plan run patching::snapshot_vmare --targets linux_patching,windows_patching action='delete'
```

##### CLI - Customize the pre/post update plans to use your own module's version

```puppet
bolt plan run patching --targets linux_patching pre_update_plan='mymodule::pre_update' post_update_plan='mymodule::post_update'
```

##### CLI - Wait 10 minutes for systems to become available as some systems take longer to reboot.

```puppet
bolt plan run patching --targets linux_patching,windows_patching --reboot_wait 600
```

#### Parameters

The following parameters are available in the `patching` plan:

* [`targets`](#targets)
* [`filter_offline_targets`](#filter_offline_targets)
* [`monitoring_enabled`](#monitoring_enabled)
* [`monitoring_plan`](#monitoring_plan)
* [`update_provider`](#update_provider)
* [`pre_update_plan`](#pre_update_plan)
* [`post_update_plan`](#post_update_plan)
* [`reboot_message`](#reboot_message)
* [`reboot_strategy`](#reboot_strategy)
* [`reboot_wait`](#reboot_wait)
* [`snapshot_plan`](#snapshot_plan)
* [`snapshot_create`](#snapshot_create)
* [`snapshot_delete`](#snapshot_delete)
* [`report_format`](#report_format)
* [`report_file`](#report_file)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="filter_offline_targets"></a>`filter_offline_targets`

Data type: `Boolean`

Flag to determine if offline targets should be filtered out of the list of targets
returned by this plan. If true, when running the <code>puppet_agent::version</code>
check, any targets that return an error will be filtered out and ignored.
Those targets will not be returned in any of the data structures in the result of
this plan. If false, then any targets that are offline will cause this plan to error
immediately when performing the online check. This will result in a halt of the
patching process.

Default value: ``false``

##### <a name="monitoring_enabled"></a>`monitoring_enabled`

Data type: `Optional[Boolean]`

Flag to enable/disable the execute of the monitoring_plan.
This is useful if you don't want to call out to a monitoring system during provisioning.
To configure this globally, use the `patching_monitoring_enabled` var.

Default value: ``undef``

##### <a name="monitoring_plan"></a>`monitoring_plan`

Data type: `Optional[String]`

Name of the plan to use for disabling/enabling monitoring steps of the workflow.
To configure this globally, use the `patching_monitoring_plan` var.

Default value: ``undef``

##### <a name="update_provider"></a>`update_provider`

Data type: `Optional[String]`

What update provider to use. For Linux (RHEL, Debian, SUSE, etc.) this parameter
is not used. For Windows the available values are: 'windows', 'chocolatey', 'all'
(both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all'
is passed and Chocolatey isn't installed then Chocolatey will simply be skipped.
If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

Default value: ``undef``

##### <a name="pre_update_plan"></a>`pre_update_plan`

Data type: `Optional[String]`

Name of the plan to use for executing the pre-update step of the workflow.

Default value: ``undef``

##### <a name="post_update_plan"></a>`post_update_plan`

Data type: `Optional[String]`

Name of the plan to use for executing the post-update step of the workflow.

Default value: ``undef``

##### <a name="reboot_message"></a>`reboot_message`

Data type: `Optional[String]`

Message displayed to the user prior to the system rebooting

Default value: ``undef``

##### <a name="reboot_strategy"></a>`reboot_strategy`

Data type: `Optional[Enum['only_required', 'never', 'always']]`

Determines the reboot strategy for the run.

 - 'only_required' only reboots hosts that require it based on info reported from the OS
 - 'never' never reboots the hosts
 - 'always' will reboot the host no matter what

Default value: ``undef``

##### <a name="reboot_wait"></a>`reboot_wait`

Data type: `Optional[Integer]`

Time in seconds that the plan waits before continuing after a reboot. This is necessary in case one
of the groups affects the availability of a previous group.
Two use cases here:
 1. A later group is a hypervisor. In this instance the hypervisor will reboot causing the
    VMs to go offline and we need to wait for those child VMs to come back up before
    collecting history metrics.
 2. A later group is a linux router. In this instance maybe the patching of the linux router
    affects the reachability of previous hosts.

Default value: ``undef``

##### <a name="snapshot_plan"></a>`snapshot_plan`

Data type: `Optional[String]`

Name of the plan to use for executing snaphot creation and deletion steps of the workflow
You can also pass `'disabled'` or `undef'` as an easy way to disable both creation and deletion.

Default value: ``undef``

##### <a name="snapshot_create"></a>`snapshot_create`

Data type: `Optional[Boolean]`

Flag to enable/disable creating snapshots before patching groups.
A common usecase to disabling snapshot creation is that, say you run patching
with `snapshot_create` enabled and something goes wrong during patching and
the run fails. The sanpshot still exists and you want to retry patching
but don't want to create ANOTHER snapshot on top of the one we already have.
In this case we would pass in `snapshot_create=false` when running the second time.

Default value: ``undef``

##### <a name="snapshot_delete"></a>`snapshot_delete`

Data type: `Optional[Boolean]`

Flag to enable/disable deleting snapshots after patching groups.
A common usecase to disable snapshot deletion is that, say you want to patch your
hosts and wait a few hours for application teams to test after you're done patching.
In this case you can run with `snapshot_delete=false` and then a few hours later
you can run the `patching::snapshot_vmware action=delete` sometime in the future.

Default value: ``undef``

##### <a name="report_format"></a>`report_format`

Data type: `Optional[Enum['none', 'pretty', 'csv']]`

The method of formatting the report data.

Default value: ``undef``

##### <a name="report_file"></a>`report_file`

Data type: `Optional[String]`

Path of the filename where the report should be written. Default = 'patching_report.csv'.
If you would like to disable writing the report file, specify a value of 'disabled'.
NOTE: If you're running PE, then you'll need to disable writing reports because it will
fail when running from the console.

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: ``false``

### <a name="patchingavailable_updates"></a>`patching::available_updates`

This uses the <code>patching::available_updates</code> task to query each Target's
Operating System for available updates. The results from the OS are parsed and formatted
into easy to consume JSON data, such that further code can be written against the
output.

 - RHEL: This ultimately performs a <code>yum check-update</code>.
 - Ubuntu: This ultimately performs a <code>apt upgrade --simulate</code>.
 - Windows:
   - Windows Update API: Queries the WUA for updates. This is the standard update mechanism
     for Windows.
   - Chocolatey: If installed, runs <code>choco outdated</code>.
     If not installed, Chocolatey is ignored.

#### Examples

##### CLI - Basic Usage

```puppet
bolt plan run patching::available_updates --targets linux_hosts
```

##### CLI - Get available update information in CSV format for creating reports

```puppet
bolt plan run patching::available_updates --targets linux_hosts format=csv
```

##### Plan - Basic Usage

```puppet
run_plan('patching::available_updates', $linux_hosts)
```

##### Plan - Get available update information in CSV format for creating reports

```puppet
run_plan('patching::available_updates', $linux_hosts,
         format => 'csv')
```

#### Parameters

The following parameters are available in the `patching::available_updates` plan:

* [`targets`](#targets)
* [`format`](#format)
* [`noop`](#noop)
* [`provider`](#provider)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="format"></a>`format`

Data type: `Enum['none', 'pretty', 'csv']`

Output format for printing user-friendly information during the plan run.
This also determines the format of the information returned from this plan.

  - 'none' : Prints no data to the screen. Returns the raw ResultSet from
     the patching::available_updates task
  - 'pretty' : Prints the data out in a easy to consume format, one line per host,
     showing the number of available updates per host. Returns a Hash containing
     two keys: 'has_updates' - an array of TargetSpec that have updates available,
     'no_updates' - an array of hosts that have no updates available.
  - 'csv' : Prints and returns CSV formatted data, one row for each update of each host.

Default value: `'pretty'`

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Run this plan in noop mode, meaning no changes will be made to end systems.
In this case, noop mode has no effect.

Default value: ``false``

##### <a name="provider"></a>`provider`

Data type: `Optional[String]`

What update provider to use. For Linux (RHEL, Debian, SUSE, etc.) this parameter
is not used. For Windows the available values are: 'windows', 'chocolatey', 'all'
(both 'windows' and 'chocolatey'). The default value for Windows is 'all'. If 'all'
is passed and Chocolatey isn't installed then Chocolatey will simply be skipped.
If 'chocolatey' is passed and Chocolatey isn't installed, then this will error.

Default value: ``undef``

### <a name="patchingcheck_online"></a>`patching::check_online`

Online checks are done querying for the node's Puppet version using the
<code>puppet_agent::version</code> task.
This plan is designed to be used ad-hoc as a quick health check of your inventory.
It is the intention of this plan to be used as "first pass" when onboarding new targets
into a Bolt rotation.
One would build their inventory file of all targets from their trusted data sources.
Then take the inventory files and run this plan against them to isolate problem targets
and remediate them.
Once this plan runs successfuly on your inventory, you know that Bolt can connect
and can begin the patching proces.

There are no results returned by this plan, instead data is pretty-printed to the screen in
two lists:

  1. List of targets that failed to connect. This list is a YAML list where each line
     is the name of a Target that failed to connect.
     The intention here is that you can use this YAML list to modify your inventory
     and remove these problem hosts from your groups.
  2. Details for each failed target. This provides details about the error that
     occured when connecting. Failures can occur for many reasons, host being offline
     host not listening on the right port, firewall blocking, invalid credentials, etc.
     The idea here is to give the end-user a easily digestible summary so that action
     can be taken to remediate these hosts.

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::check_online
```

#### Parameters

The following parameters are available in the `patching::check_online` plan:

* [`targets`](#targets)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

### <a name="patchingcheck_puppet"></a>`patching::check_puppet`

Executes the <code>puppet_agent::version</code> task to check if Puppet is installed
on all of the targets. Once finished, the result is split into two groups:

 1. Targets with puppet
 2. Targets with no puppet

The targets with puppet are queried for facts using the <code>patching::puppet_facts</code> plan.
Targets without puppet are queried for facts using the simpler <code>facts</code> plan.

This plan is designed to be the first plan executed in a patching workflow.
It can be used to stop the patching process if any hosts are offline by setting
<code>filter_offline_targets=false</code> (default). It can also be used
to patch any hosts that are currently available and ignoring any offline targets
by setting <code>filter_offline_targets=true</code>.

#### Examples

##### CLI - Basic usage (error if any targets are offline)

```puppet
bolt plan run patching::check_puppet --targets linux_hosts
```

##### CLI - Filter offline targets (only return online targets)

```puppet
bolt plan run patching::check_puppet --targets linux_hosts filter_offline_targets=true
```

##### Plan - Basic usage (error if any targets are offline)

```puppet
$results = run_plan('patching::check_puppet', $linux_hosts)
$targets_has_puppet = $results['has_puppet']
$targets_no_puppet = $results['no_puppet']
$targets_all = $results['all']
```

##### Plan - Filter offline targets (only return online targets)

```puppet
$results = run_plan('patching::check_puppet', $linux_hosts,
                    filter_offline_targets => true)
$targets_online_has_puppet = $results['has_puppet']
$targets_online_no_puppet = $results['no_puppet']
$targets_online = $results['all']
```

#### Parameters

The following parameters are available in the `patching::check_puppet` plan:

* [`targets`](#targets)
* [`filter_offline_targets`](#filter_offline_targets)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="filter_offline_targets"></a>`filter_offline_targets`

Data type: `Boolean`

Flag to determine if offline targets should be filtered out of the list of targets
returned by this plan. If true, when running the <code>puppet_agent::version</code>
check, any targets that return an error will be filtered out and ignored.
Those targets will not be returned in any of the data structures in the result of
this plan. If false, then any targets that are offline will cause this plan to error
immediately when performing the online check. This will result in a halt of the
patching process.

Default value: ``false``

### <a name="patchingdeploy_scripts"></a>`patching::deploy_scripts`

The patching::deploy_scripts class.

#### Examples

##### CLI deploy a pre patching script

```puppet
bolt plan run patching::deploy_scripts scripts='{"pre_patch.sh": {"source": "puppet:///modules/test/patching/pre_patch.sh"}}'
```

##### CLI deploy a pre and post patching script

```puppet
bolt plan run patching::deploy_scripts scripts='{"pre_patch.sh": {"source": "puppet:///modules/test/patching/pre_patch.sh"}, "post_patch.sh": {"source": "puppet:///modules/test/patching/post_patch.sh"}}'
```

#### Parameters

The following parameters are available in the `patching::deploy_scripts` plan:

* [`owner`](#owner)
* [`group`](#group)
* [`mode`](#mode)
* [`targets`](#targets)
* [`scripts`](#scripts)
* [`patching_dir`](#patching_dir)
* [`bin_dir`](#bin_dir)
* [`log_dir`](#log_dir)

##### <a name="owner"></a>`owner`

Data type: `Optional[String]`

Default owner of installed scripts

Default value: ``undef``

##### <a name="group"></a>`group`

Data type: `Optional[String]`

Default group of installed scripts

Default value: ``undef``

##### <a name="mode"></a>`mode`

Data type: `Optional[String]`

Default file mode of installed scripts

Default value: ``undef``

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`



##### <a name="scripts"></a>`scripts`

Data type: `Hash`



##### <a name="patching_dir"></a>`patching_dir`

Data type: `Optional[String]`



Default value: ``undef``

##### <a name="bin_dir"></a>`bin_dir`

Data type: `Optional[String]`



Default value: ``undef``

##### <a name="log_dir"></a>`log_dir`

Data type: `Optional[String]`



Default value: ``undef``

### <a name="patchingget_facts"></a>`patching::get_facts`

Sets patching facts on targets

#### Examples

##### Get the patching_group fact (default)

```puppet
bolt plan run patching::get_facts --targets xxx
```

##### Get different facts

```puppet
bolt plan run patching::get_facts --targets xxx names='["fact1", "fact2"]'
```

#### Parameters

The following parameters are available in the `patching::get_facts` plan:

* [`targets`](#targets)
* [`names`](#names)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="names"></a>`names`

Data type: `Variant[String, Array[String]]`

Name or list of fact names to retrieve from the targets

Default value: `['patching_group']`

### <a name="patchingget_targets"></a>`patching::get_targets`

A very common requirement when running individual plans from the commandline is that
each plan would need to perform the following steps:
 - Convert the TargetSpec from a string into an Array[Target] using <code>get_targets($targets)</code>
 - Check for targets that are online (calls plan <code>patching::check_puppet</code>
 - Gather facts about the targets

This plan combines all of that into one so that it can be reused in all of the other
plans within this module. It also adds some smart checking so that, if multiple plans
invoke each other, each of which call this plan. The online check and facts gathering
only hapens once.

#### Examples

##### Plan - Basic usage

```puppet
plan mymodule::myplan (
  TargetSpec $targets
) {
  $targets = run_plan('patching::get_targets', $targets)
  # do normal stuff with your $targets
}
```

#### Parameters

The following parameters are available in the `patching::get_targets` plan:

* [`targets`](#targets)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

### <a name="patchingmonitoring_multiple"></a>`patching::monitoring_multiple`

Disable monitoring for targets in multiple services

#### Examples

##### Remote target definition for $monitoring_target

```puppet
vars:
  patching_monitoring_plan: 'patching::monitoring_multiple'
  patching_monitoring_plan_multiple:
    - plan: 'patching::monitoring_solarwinds'
      target: 'solarwinds'
    - plan: 'patching::monitoring_prometheus'
      target: 'prometheus'

groups:
  - name: solarwinds
    config:
      transport: remote
      remote:
        port: 17778
        username: 'domain\svc_bolt_sw'
        password:
          _plugin: pkcs7
          encrypted_value: >
            ENC[PKCS7,xxx]
    targets:
      - solarwinds.domain.tld

  - name: prometheus
    config:
      transport: remote
      remote:
        username: 'domain\prom_user'
        password:
          _plugin: pkcs7
          encrypted_value: >
            ENC[PKCS7,xxx]
    targets:
      - prometheus.domain.tld
```

#### Parameters

The following parameters are available in the `patching::monitoring_multiple` plan:

* [`targets`](#targets)
* [`action`](#action)
* [`noop`](#noop)
* [`monitoring_plans`](#monitoring_plans)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="action"></a>`action`

Data type: `Enum['enable', 'disable']`

What action to perform on the monitored targets:

  - `enable` Resumes monitoring alerts
  - 'disable' Supresses monitoring alerts

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode.

Default value: ``false``

##### <a name="monitoring_plans"></a>`monitoring_plans`

Data type: `Array[Hash]`



Default value: `.vars['patching_monitoring_plan_multiple']`

### <a name="patchingmonitoring_prometheus"></a>`patching::monitoring_prometheus`

Create or remove alert silences for hosts in Prometheus.

#### Examples

##### Remote target definition for $monitoring_target

```puppet
vars:
  patching_monitoring_target: 'prometheus'
  patching_monitoring_silence_duration: 24
  patching_monitoring_silence_units: 'hours'

groups:
  - name: prometheus
    config:
      transport: remote
      remote:
        username: 'domain\prom_user'
        password:
          _plugin: pkcs7
          encrypted_value: >
            ENC[PKCS7,xxx]
    targets:
      - prometheus.domain.tld
```

#### Parameters

The following parameters are available in the `patching::monitoring_prometheus` plan:

* [`targets`](#targets)
* [`action`](#action)
* [`monitoring_silence_duration`](#monitoring_silence_duration)
* [`monitoring_silence_units`](#monitoring_silence_units)
* [`monitoring_target`](#monitoring_target)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="action"></a>`action`

Data type: `Enum['enable', 'disable']`

What action to perform on the monitored targets:

  - `enable` Resumes monitoring alerts
  - 'disable' Supresses monitoring alerts

##### <a name="monitoring_silence_duration"></a>`monitoring_silence_duration`

Data type: `Optional[Integer]`

How long the alert silence will be alive for

Default value: ``undef``

##### <a name="monitoring_silence_units"></a>`monitoring_silence_units`

Data type: `Optional[Enum['minutes', 'hours', 'days', 'weeks']]`

Goes with the silence duration to determine how long the alert silence will be alive for

Default value: ``undef``

##### <a name="monitoring_target"></a>`monitoring_target`

Data type: `Optional[TargetSpec]`

Name or reference to the remote transport target of the Prometheus server.
The remote transport should have the following properties:
  - [String] username
      Username for authenticating with Prometheus
  - [Password] password
      Password for authenticating with Prometheus

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: ``false``

### <a name="patchingmonitoring_solarwinds"></a>`patching::monitoring_solarwinds`

TODO config variables

#### Examples

##### Remote target definition for $monitoring_target

```puppet
vars:
  patching_monitoring_plan: 'patching::monitoring_solarwinds'
  patching_monitoring_target: 'solarwinds'

groups:
  - name: solarwinds
    config:
      transport: remote
      remote:
        port: 17778
        username: 'domain\svc_bolt_sw'
        password:
          _plugin: pkcs7
          encrypted_value: >
            ENC[PKCS7,xxx]
    targets:
      - solarwinds.domain.tld
```

#### Parameters

The following parameters are available in the `patching::monitoring_solarwinds` plan:

* [`targets`](#targets)
* [`action`](#action)
* [`target_name_property`](#target_name_property)
* [`monitoring_target`](#monitoring_target)
* [`monitoring_name_property`](#monitoring_name_property)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="action"></a>`action`

Data type: `Enum['enable', 'disable']`

What action to perform on the monitored targets:

  - `enable` Resumes monitoring alerts
  - 'disable' Supresses monitoring alerts

##### <a name="target_name_property"></a>`target_name_property`

Data type: `Optional[Enum['name', 'uri']]`

Determines what property on the Target object will be used as the name when
mapping the Target to a Node in SolarWinds.

 - `uri` : use the `uri` property on the Target. This is preferred because
    If you specify a list of Targets in the inventory file, the value shown in that
    list is set as the `uri` and not the `name`, in this case `name` will be `undef`.
 - `name` : use the `name` property on the Target, this is not preferred because
    `name` is usually a short name or nickname.

Default value: ``undef``

##### <a name="monitoring_target"></a>`monitoring_target`

Data type: `Optional[TargetSpec]`

Name or reference to the remote transport target of the Monitoring server.
This will be used when to determine how to communicate with the SolarWinds API.
The remote transport should have the following properties:
  - [Integer] port
      Port to use when communicating with SolarWinds API (default: 17778)
  - [String] username
      Username for authenticating with the SolarWinds API
  - [Password] password
      Password for authenticating with the SolarWinds API

Default value: ``undef``

##### <a name="monitoring_name_property"></a>`monitoring_name_property`

Data type: `Optional[String[1]]`

Determines what property to match in SolarWinds when looking up targets.
By default we determine if the target's name is an IP address, if it is then we
use the 'IPAddress' property, otherwise we use whatever property this is set to.
Available options that we've seen used are 'DNS' if the target's name is a DNS FQDN,
or 'Caption' if you're looking up by a nick-name for the target.
This can really be any field on the Orion.Nodes table.

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: ``false``

### <a name="patchingordered_groups"></a>`patching::ordered_groups`

When patching hosts it is common that you don't want to patch them all at the same time,
for obvious reasons. To facilitate this we devised the concept of a "patching order".
Patching order is a mechanism to allow targets to be organized into groups and
then sorted so that a custom order can be defined for your specific usecase.

The way one assigns a patching order to a target or group is using <code>vars</code>
in the Bolt inventory file.

Example:

```yaml
---
groups:
  - name: primary_nodes
    vars:
      patching_order: 1
    targets:
      - sql01.domain.tld

  - name: backup_nodes
    vars:
      patching_order: 2
    targets:
      - sql02.domain.tld
```

When the <code>patching_order</code> is defined at the group level, it is inherited
by all targets within that group.

The reason this plan exists is that there is no concept of a "group" in the bolt
runtime, so we need to artificially recreate them using our <code>patching_order</code>
vars paradigm.

An added benefit to this paradigm is that you may have grouped your targets logically
on a different dimension, say by application. If it's OK that multiple applications be
patched at the same time, we can assign the same patching order to multiple groups
in the inventory. Then, when run through this plan, they will be aggregated together
into one large group of targets that will all be patched concurrently.

Example, app_xxx and app_zzz both can be patched at the same time, but app_yyy needs to go
later in the process:

```yaml
---
groups:
  - name: app_xxx
    vars:
      patching_order: 1
    targets:
      - xxx

  - name: app_yyy
    vars:
      patching_order: 2
    targets:
      - yyy

  - name: app_zzz
    vars:
      patching_order: 1
    targets:
      - zzz
```

 This is returned as an Array, because an Array has a defined order when
 you iterate over it using <code>.each</code>. Ordering is important in patching
 so we wanted this to be very concrete.

#### Examples

##### Basic usage

```puppet
$ordered_groups = run_plan('patching::ordered_groups', $targets)
$ordered_groups.each |$group_hash| {
  $group_order = $group_hash['order']
  $group_targets = $group_hash['targets']
  # run your patching process for the group
}
```

#### Parameters

The following parameters are available in the `patching::ordered_groups` plan:

* [`targets`](#targets)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to created ordered groups of.

### <a name="patchingpost_update"></a>`patching::post_update`

Often in patching it is necessary to run custom commands before/after updates are
applied to a host. This plan allows for that customization to occur.

By default it executes a Shell script on Linux and a PowerShell script on Windows hosts.
The default script paths are:
  - Linux: `/opt/patching/bin/post_update.sh`
  - Windows: `C:\ProgramData\patching\bin\post_update.ps1`

One can customize the script paths by overriding them on the CLI, or when calling the plan
using the `script_linux` and `script_windows` parameters.

The script paths can also be customzied in the inventory configuration `vars`:
Example:

``` yaml
vars:
  patching_post_update_script_windows: C:\scripts\patching.ps1
  patching_post_update_script_linux: /usr/local/bin/mysweetpatchingscript.sh

groups:
  # these targets will use the pre patching script defined in the vars above
  - name: regular_nodes
    targets:
      - tomcat01.domain.tld

  # these targets will use the customized patching script set for this group
  - name: sql_nodes
    vars:
      patching_post_update_script_linux: /bin/sqlpatching.sh
    targets:
      - sql01.domain.tld
```

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::post_update --targets all_hosts
```

##### CLI - Custom scripts

```puppet
bolt plan run patching::post_update --targets all_hosts script_linux='/my/sweet/script.sh' script_windows='C:\my\sweet\script.ps1'
```

##### Plan - Basic usage

```puppet
run_plan('patching::post_update', $all_hosts)
```

##### Plan - Custom scripts

```puppet
run_plan('patching::post_update', $all_hosts,
         script_linux   => '/my/sweet/script.sh',
         script_windows => 'C:\my\sweet\script.ps1')
```

#### Parameters

The following parameters are available in the `patching::post_update` plan:

* [`targets`](#targets)
* [`script_linux`](#script_linux)
* [`script_windows`](#script_windows)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="script_linux"></a>`script_linux`

Data type: `String[1]`

Path to the script that will be executed on Linux targets.

Default value: `'/opt/patching/bin/post_update.sh'`

##### <a name="script_windows"></a>`script_windows`

Data type: `String[1]`

Path to the script that will be executed on Windows targets.

Default value: `'C:\ProgramData\patching\bin\post_update.ps1'`

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: ``false``

### <a name="patchingpre_post_update"></a>`patching::pre_post_update`

Common entry point for executing the pre/post update custom scripts

* **See also**
  * patching::pre_update
  * patching::post_update

#### Parameters

The following parameters are available in the `patching::pre_post_update` plan:

* [`targets`](#targets)
* [`task`](#task)
* [`script_linux`](#script_linux)
* [`script_windows`](#script_windows)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="task"></a>`task`

Data type: `String[1]`

Name of the pre/post update task to execute.

##### <a name="script_linux"></a>`script_linux`

Data type: `Optional[String[1]]`

Path to the script that will be executed on Linux targets.

Default value: ``undef``

##### <a name="script_windows"></a>`script_windows`

Data type: `Optional[String[1]]`

Path to the script that will be executed on Windows targets.

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: ``false``

### <a name="patchingpre_update"></a>`patching::pre_update`

Often in patching it is necessary to run custom commands before/after updates are
applied to a host. This plan allows for that customization to occur.

By default it executes a Shell script on Linux and a PowerShell script on Windows hosts.
The default script paths are:
  - Linux: `/opt/patching/bin/pre_update.sh`
  - Windows: `C:\ProgramData\patching\bin\pre_update.ps1`

One can customize the script paths by overriding them on the CLI, or when calling the plan
using the `script_linux` and `script_windows` parameters.

The script paths can also be customzied in the inventory configuration `vars`:
Example:

``` yaml
vars:
  patching_pre_update_script_windows: C:\scripts\patching.ps1
  patching_pre_update_script_linux: /usr/local/bin/mysweetpatchingscript.sh

groups:
  # these targets will use the pre patching script defined in the vars above
  - name: regular_nodes
    targets:
      - tomcat01.domain.tld

  # these targets will use the customized patching script set for this group
  - name: sql_nodes
    vars:
      patching_pre_update_script_linux: /bin/sqlpatching.sh
    targets:
      - sql01.domain.tld
```

#### Examples

##### CLI - Basic usage

```puppet
bolt plan run patching::pre_update --targets all_hosts
```

##### CLI - Custom scripts

```puppet
bolt plan run patching::pre_update --targets all_hosts script_linux='/my/sweet/script.sh' script_windows='C:\my\sweet\script.ps1'
```

##### Plan - Basic usage

```puppet
run_plan('patching::pre_update', $all_hosts)
```

##### Plan - Custom scripts

```puppet
run_plan('patching::pre_update', $all_hosts,
         script_linux   => '/my/sweet/script.sh',
         script_windows => 'C:\my\sweet\script.ps1')
```

#### Parameters

The following parameters are available in the `patching::pre_update` plan:

* [`targets`](#targets)
* [`script_linux`](#script_linux)
* [`script_windows`](#script_windows)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="script_linux"></a>`script_linux`

Data type: `String[1]`

Path to the script that will be executed on Linux targets.

Default value: `'/opt/patching/bin/pre_update.sh'`

##### <a name="script_windows"></a>`script_windows`

Data type: `String[1]`

Path to the script that will be executed on Windows targets.

Default value: `'C:\ProgramData\patching\bin\pre_update.ps1'`

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode for the underlying plans and tasks.

Default value: ``false``

### <a name="patchingpuppet_facts"></a>`patching::puppet_facts`

This is inspired by: https://github.com/puppetlabs/puppetlabs-facts/blob/master/plans/init.pp
Except instead of just running `facter` it runs `puppet facts` to set additional
facts that are only present when in the context of puppet.

Under the hood it is executeing the `patching::puppet_facts` task.

#### Parameters

The following parameters are available in the `patching::puppet_facts` plan:

* [`targets`](#targets)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

### <a name="patchingreboot_required"></a>`patching::reboot_required`

Patching in different environments comes with various unique requirements, one of those
is rebooting hosts. Sometimes hosts need to always be reboot, othertimes never rebooted.

To provide this flexibility we created this function that wraps the `reboot` plan with
a `strategy` that is controllable as a parameter. This provides flexibilty in
rebooting specific targets in certain ways (by group). Along with the power to expand
our strategy offerings in the future.

#### Parameters

The following parameters are available in the `patching::reboot_required` plan:

* [`targets`](#targets)
* [`strategy`](#strategy)
* [`message`](#message)
* [`wait`](#wait)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="strategy"></a>`strategy`

Data type: `Enum['only_required', 'never', 'always']`

Determines the reboot strategy for the run.

 - 'only_required' only reboots hosts that require it based on info reported from the OS
 - 'never' never reboots the hosts
 - 'always' will reboot the host no matter what

Default value: ``undef``

##### <a name="message"></a>`message`

Data type: `String`

Message displayed to the user prior to the system rebooting

Default value: ``undef``

##### <a name="wait"></a>`wait`

Data type: `Integer`

Time in seconds that the plan waits before continuing after a reboot. This is necessary in case one
of the groups affects the availability of a previous group.
Two use cases here:
 1. A later group is a hypervisor. In this instance the hypervisor will reboot causing the
    VMs to go offline and we need to wait for those child VMs to come back up before
    collecting history metrics.
 2. A later group is a linux router. In this instance maybe the patching of the linux router
    affects the reachability of previous hosts.

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to determine if this should be a noop operation or not.
If this is a noop, no hosts will ever be rebooted, however the "reboot required" information
will still be queried and returned.

Default value: ``false``

### <a name="patchingset_facts"></a>`patching::set_facts`

For Linux targets the facts will be written to <code>/etc/facter/facts.d/patching.yaml</code>.
For Windows targets the facts will be written to <code>'C:/ProgramData/PuppetLabs/facter/facts.d/patching.yaml'</code>.

The contents of the <code>patching.yaml</code> file will be overwritten by this plan.
TODO: Provide an option to merge with existing facts.

Once the facts are written, by default, the facts will be ran and uploaded to PuppetDB.
If you wish to disable this, simply set <code>upload=false</code>

#### Examples

##### Set the patching_group fact

```puppet
bolt plan run patching::set_facts --targets xxx patching_group=tuesday_night
```

##### Set the custom facts

```puppet
bolt plan run patching::set_facts --targets xxx custom_facts='{"fact1": "blah"}'
```

##### Don't upload facts to PuppetDB

```puppet
bolt plan run patching::set_facts --targets xxx patching_group=tuesday_night upload=false
```

#### Parameters

The following parameters are available in the `patching::set_facts` plan:

* [`targets`](#targets)
* [`patching_group`](#patching_group)
* [`custom_facts`](#custom_facts)
* [`upload`](#upload)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="patching_group"></a>`patching_group`

Data type: `Optional[String]`

Name of the patching group that the targets are a member of. This will be the value for the
<code>patching_group</code> fact.

Default value: ``undef``

##### <a name="custom_facts"></a>`custom_facts`

Data type: `Hash`

Hash of custom facts that will be set on these targets. This can be anything you like
and will merged with the other facts above.

Default value: `{}`

##### <a name="upload"></a>`upload`

Data type: `Boolean`

After setting the facts, perform a <code>puppet facts upload</code> so the new
facts are stored in PuppetDB.

Default value: ``true``

### <a name="patchingsnapshot_kvm"></a>`patching::snapshot_kvm`

Runs commands on the CLI of the KVM/Libvirt hypervisor host.

#### Parameters

The following parameters are available in the `patching::snapshot_kvm` plan:

* [`targets`](#targets)
* [`action`](#action)
* [`target_name_property`](#target_name_property)
* [`snapshot_name`](#snapshot_name)
* [`snapshot_description`](#snapshot_description)
* [`snapshot_memory`](#snapshot_memory)
* [`snapshot_quiesce`](#snapshot_quiesce)
* [`hypervisor_targets`](#hypervisor_targets)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="action"></a>`action`

Data type: `Enum['create', 'delete']`

What action to perform on the snapshots:

  - `create` creates a new snapshot
  - 'delete' deletes snapshots by matching the `snapshot_name` passed in.

##### <a name="target_name_property"></a>`target_name_property`

Data type: `Optional[Enum['hostname', 'name', 'uri']]`

Determines what property on the Target object will be used as the VM name when
mapping the Target to a VM in vSphere.

 - `uri` : use the `uri` property on the Target. This is preferred because
    If you specify a list of Targets in the inventory file, the value shown in that
    list is set as the `uri` and not the `name`, in this case `name` will be `undef`.
 - `name` : use the `name` property on the Target, this is not preferred because
    `name` is usually a short name or nickname.
 - `hostname`: use the `hostname` value to use host component of `uri` property on the Target
   this can be useful if VM name doesn't include domain name

Default value: ``undef``

##### <a name="snapshot_name"></a>`snapshot_name`

Data type: `Optional[String[1]]`

Name of the snapshot

Default value: ``undef``

##### <a name="snapshot_description"></a>`snapshot_description`

Data type: `Optional[String]`

Description of the snapshot

Default value: ``undef``

##### <a name="snapshot_memory"></a>`snapshot_memory`

Data type: `Optional[Boolean]`

Capture the VMs memory in the snapshot

Default value: ``undef``

##### <a name="snapshot_quiesce"></a>`snapshot_quiesce`

Data type: `Optional[Boolean]`

Quiesce/flush the filesystem when snapshotting the VM. This requires VMware tools be installed
in the guest OS to work properly.

Default value: ``undef``

##### <a name="hypervisor_targets"></a>`hypervisor_targets`

Data type: `Optional[TargetSpec]`

Name or reference to the targets of the KVM hypervisors.
We will login to this host an run the snapshot tasks so that the local CLI can be used.
Default target name is "kvm_hypervisors", this can be a group of targets too!

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: ``false``

### <a name="patchingsnapshot_vmware"></a>`patching::snapshot_vmware`

Communicates to the vSphere API from the local Bolt control node using
the [rbvmomi](https://github.com/vmware/rbvmomi) Ruby gem.

To install the rbvmomi gem on the bolt control node:
```shell
  /opt/puppetlabs/bolt/bin/gem install --user-install rbvmomi
```

TODO config variables

#### Parameters

The following parameters are available in the `patching::snapshot_vmware` plan:

* [`targets`](#targets)
* [`action`](#action)
* [`target_name_property`](#target_name_property)
* [`vsphere_host`](#vsphere_host)
* [`vsphere_username`](#vsphere_username)
* [`vsphere_password`](#vsphere_password)
* [`vsphere_datacenter`](#vsphere_datacenter)
* [`vsphere_insecure`](#vsphere_insecure)
* [`snapshot_name`](#snapshot_name)
* [`snapshot_description`](#snapshot_description)
* [`snapshot_memory`](#snapshot_memory)
* [`snapshot_quiesce`](#snapshot_quiesce)
* [`noop`](#noop)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="action"></a>`action`

Data type: `Enum['create', 'delete']`

What action to perform on the snapshots:

  - `create` creates a new snapshot
  - 'delete' deletes snapshots by matching the `snapshot_name` passed in.

##### <a name="target_name_property"></a>`target_name_property`

Data type: `Optional[Enum['hostname', 'name', 'uri']]`

Determines what property on the Target object will be used as the VM name when
mapping the Target to a VM in vSphere.

 - `uri` : use the `uri` property on the Target. This is preferred because
    If you specify a list of Targets in the inventory file, the value shown in that
    list is set as the `uri` and not the `name`, in this case `name` will be `undef`.
 - `name` : use the `name` property on the Target, this is not preferred because
    `name` is usually a short name or nickname.
 - `hostname`: use the `hostname` value to use host component of `uri` property on the Target
   this can be useful if VM name doesn't include domain name

Default value: ``undef``

##### <a name="vsphere_host"></a>`vsphere_host`

Data type: `String[1]`

Hostname of the vSphere server that we're going to use to create snapshots via the API.

Default value: `.vars['vsphere_host']`

##### <a name="vsphere_username"></a>`vsphere_username`

Data type: `String[1]`

Username to use when authenticating with the vSphere API.

Default value: `.vars['vsphere_username']`

##### <a name="vsphere_password"></a>`vsphere_password`

Data type: `String[1]`

Password to use when authenticating with the vSphere API.

Default value: `.vars['vsphere_password']`

##### <a name="vsphere_datacenter"></a>`vsphere_datacenter`

Data type: `String[1]`

Name of the vSphere datacenter to search for VMs under.

Default value: `.vars['vsphere_datacenter']`

##### <a name="vsphere_insecure"></a>`vsphere_insecure`

Data type: `Boolean`

Flag to enable insecure HTTPS connections by disabling SSL server certificate verification.

Default value: `.vars['vsphere_insecure']`

##### <a name="snapshot_name"></a>`snapshot_name`

Data type: `Optional[String[1]]`

Name of the snapshot

Default value: ``undef``

##### <a name="snapshot_description"></a>`snapshot_description`

Data type: `Optional[String]`

Description of the snapshot

Default value: ``undef``

##### <a name="snapshot_memory"></a>`snapshot_memory`

Data type: `Optional[Boolean]`

Capture the VMs memory in the snapshot

Default value: ``undef``

##### <a name="snapshot_quiesce"></a>`snapshot_quiesce`

Data type: `Optional[Boolean]`

Quiesce/flush the filesystem when snapshotting the VM. This requires VMware tools be installed
in the guest OS to work properly.

Default value: ``undef``

##### <a name="noop"></a>`noop`

Data type: `Boolean`

Flag to enable noop mode. When noop mode is enabled no snapshots will be created or deleted.

Default value: ``false``

### <a name="patchingupdate_history"></a>`patching::update_history`

When executing the `patching::update` task, the data that is returned to Bolt
is also written into a "results" file. This plan reads the last JSON document
from that results file, then formats the results in various ways.

This is useful for gather patching report data on a fleet of servers.

If you're using this in a larger workflow and you've run `patching::update` inline.
You can pass the ResultSet from that task into the `history` parameter of this
plan and we will skip retrieving the history from the targets and simply use
that data.

By default the report is also written to a file `patching_report.csv`.
If you would like to disable this you can pass in `undef` or `'disabled'` to
`report_file` parameter. You can also customize this as by specifying the
`patching_report_file` var on the target or group.

Patching format can also be customized using the inventory var `patching_report_format`
on the target or group.

#### Parameters

The following parameters are available in the `patching::update_history` plan:

* [`targets`](#targets)
* [`history`](#history)
* [`report_file`](#report_file)
* [`format`](#format)

##### <a name="targets"></a>`targets`

Data type: `TargetSpec`

Set of targets to run against.

##### <a name="history"></a>`history`

Data type: `Optional[ResultSet]`

Optional ResultSet from the `patching::update` or `patching::update_history` tasks
that contains update result data to be formatted.

Default value: ``undef``

##### <a name="report_file"></a>`report_file`

Data type: `Optional[String]`

Optional filename to save the formatted repot into.
If `undef` or `'disabled'` are passed, then no report file will be written.
NOTE: If you're running PE, then you'll need to disable writing reports because it will
fail when running from the console.

Default value: `'patching_report.csv'`

##### <a name="format"></a>`format`

Data type: `Enum['none', 'pretty', 'csv']`

The method of formatting to use for the data.

Default value: `'pretty'`

